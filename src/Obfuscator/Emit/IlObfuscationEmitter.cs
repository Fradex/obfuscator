using System.Reflection;
using System.Text;

namespace Obfuscator.Emit;

internal sealed class IlObfuscationEmitter
{
    private readonly IlParser _parser = new();

    public string EmitFromAssembly(string assemblyPath)
    {
        var assembly = Assembly.LoadFrom(assemblyPath);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Concurrent;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using System.Reflection.Emit;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine();

        AppendRuntime(sb);

        var types = assembly.GetTypes()
            .Where(type => !type.IsNested)
            .Where(type => !type.IsGenericTypeDefinition)
            .OrderBy(type => type.Namespace)
            .ThenBy(type => type.Name)
            .ToArray();

        foreach (var group in types.GroupBy(type => type.Namespace ?? string.Empty))
        {
            if (!string.IsNullOrWhiteSpace(group.Key))
            {
                sb.AppendLine($"namespace {group.Key}");
                sb.AppendLine("{");
            }

            foreach (var type in group)
            {
                AppendType(sb, type);
            }

            if (!string.IsNullOrWhiteSpace(group.Key))
            {
                sb.AppendLine("}");
            }
        }

        return sb.ToString();
    }

    private void AppendType(StringBuilder sb, Type type)
    {
        var accessibility = type.IsPublic ? "public" : "internal";
        var kind = type.IsValueType && !type.IsEnum ? "struct" : "class";
        var baseType = type.BaseType;
        var baseTypeName = baseType is { } && baseType != typeof(object) && baseType != typeof(ValueType)
            ? $" : {CSharpName.Get(baseType)}"
            : string.Empty;

        sb.AppendLine($"    {accessibility} {kind} {type.Name}{baseTypeName}");
        sb.AppendLine("    {");

        var methods = new List<MethodBase>();
        methods.AddRange(type.GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)
            .Where(method => !method.IsAbstract)
            .Where(method => !method.ContainsGenericParameters)
            .Where(method => method.GetMethodBody() != null));

        methods.AddRange(type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)
            .Where(ctor => !ctor.ContainsGenericParameters));

        foreach (var method in methods)
        {
            AppendMethod(sb, type, method);
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void AppendMethod(StringBuilder sb, Type declaringType, MethodBase method)
    {
        var body = method.GetMethodBody();
        if (body is null)
        {
            return;
        }

        if (body.ExceptionHandlingClauses.Count > 0)
        {
            sb.AppendLine($"        // Skipped method {method.Name} due to exception handling clauses.");
            return;
        }

        var methodName = method is ConstructorInfo ? declaringType.Name : method.Name;
        if (methodName.Contains('.'))
        {
            sb.AppendLine($"        // Skipped method {methodName} due to unsupported name.");
            return;
        }
        var returnType = method is MethodInfo methodInfo ? CSharpName.Get(methodInfo.ReturnType) : "void";
        var accessibility = method.IsPublic
            ? "public"
            : method.IsFamily
                ? "protected"
                : method.IsFamilyOrAssembly
                    ? "protected internal"
                    : method.IsAssembly
                        ? "internal"
                        : "private";
        var staticModifier = method.IsStatic ? " static" : string.Empty;
        var parameters = method.GetParameters();
        var parameterSignature = string.Join(", ", parameters.Select(FormatParameter));
        var definitionName = $"__il_{methodName}_{Math.Abs(method.MetadataToken)}";

        var ilInstructions = _parser.Parse(method);

        sb.AppendLine($"        private static readonly ObfuscatedRuntime.IlMethodDefinition {definitionName} = new(");
        sb.AppendLine($"            \"{declaringType.FullName}.{methodName}:{method.MetadataToken}\",");
        sb.AppendLine("            new ObfuscatedRuntime.IlInstruction[]");
        sb.AppendLine("            {");
        foreach (var instruction in ilInstructions)
        {
            var operandLiteral = FormatOperand(instruction.Operand);
            sb.AppendLine($"                new ObfuscatedRuntime.IlInstruction({instruction.Offset}, OpCodes.{instruction.OpCode.Name}{operandLiteral}),");
        }
        sb.AppendLine("            },");

        var locals = body.LocalVariables.Select(local => $"ObfuscatedRuntime.IlMetadataResolver.ResolveType(\"{local.LocalType.AssemblyQualifiedName}\")");
        sb.AppendLine($"            new Type[] {{ {string.Join(", ", locals)} }},");
        sb.AppendLine($"            initLocals: {body.InitLocals.ToString().ToLowerInvariant()}));");
        sb.AppendLine();

        sb.AppendLine($"        {accessibility}{staticModifier} {returnType} {methodName}({parameterSignature})");
        sb.AppendLine("        {");

        var parameterTypes = new List<string>();
        var args = new List<string>();

        if (!method.IsStatic)
        {
            parameterTypes.Add($"typeof({CSharpName.Get(declaringType)})");
            args.Add("this");
        }

        for (var i = 0; i < parameters.Length; i++)
        {
            var parameter = parameters[i];
            var paramType = parameter.ParameterType;
            var typeToResolve = paramType.IsByRef ? paramType.GetElementType()! : paramType;
            var paramTypeLiteral = paramType.IsByRef
                ? $"ObfuscatedRuntime.IlMetadataResolver.ResolveType(\"{typeToResolve.AssemblyQualifiedName}\").MakeByRefType()"
                : $"ObfuscatedRuntime.IlMetadataResolver.ResolveType(\"{paramType.AssemblyQualifiedName}\")";

            parameterTypes.Add(paramTypeLiteral);
            args.Add(parameter.Name ?? $"arg{i}");
        }

        sb.AppendLine($"            var __args = new object?[] {{ {string.Join(", ", args)} }};");
        sb.AppendLine($"            var __types = new Type[] {{ {string.Join(", ", parameterTypes)} }};");

        if (returnType == "void")
        {
            sb.AppendLine($"            ObfuscatedRuntime.IlRuntime.ExecuteVoid({definitionName}, typeof(void), __types, __args);");
        }
        else
        {
            sb.AppendLine($"            var __result = ObfuscatedRuntime.IlRuntime.Execute({definitionName}, typeof({returnType}), __types, __args);");
        }

        foreach (var parameter in parameters)
        {
            if (!parameter.ParameterType.IsByRef)
            {
                continue;
            }

            var name = parameter.Name ?? "arg";
            var elementType = parameter.ParameterType.GetElementType()!;
            sb.AppendLine($"            {name} = ({CSharpName.Get(elementType)})__args[{parameter.Position + (method.IsStatic ? 0 : 1)}]!;");
        }

        if (returnType != "void")
        {
            sb.AppendLine($"            return ({returnType})__result!;");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string FormatParameter(ParameterInfo parameter)
    {
        var prefix = parameter.IsOut ? "out " : parameter.ParameterType.IsByRef ? "ref " : string.Empty;
        var typeName = CSharpName.Get(parameter.ParameterType.IsByRef ? parameter.ParameterType.GetElementType()! : parameter.ParameterType);
        return $"{prefix}{typeName} {parameter.Name}";
    }

    private static string FormatOperand(object? operand)
    {
        if (operand is null)
        {
            return string.Empty;
        }

        return operand switch
        {
            int value => $", {value}",
            short value => $", (short){value}",
            byte value => $", (byte){value}",
            sbyte value => $", (sbyte){value}",
            long value => $", {value}L",
            float value => $", {value}f",
            double value => $", {value}d",
            string value => $", \"{EscapeString(value)}\"",
            int[] targets => $", new[] {{ {string.Join(", ", targets)} }}",
            Type type => $", ObfuscatedRuntime.IlMetadataResolver.ResolveType(\"{type.AssemblyQualifiedName}\")",
            MethodInfo method => $", ObfuscatedRuntime.IlMetadataResolver.ResolveMethod(\"{method.DeclaringType?.AssemblyQualifiedName}\", \"{method.Name}\", new[] {{ {string.Join(", ", method.GetParameters().Select(param => $"\"{param.ParameterType.AssemblyQualifiedName}\""))} }}, {method.IsStatic.ToString().ToLowerInvariant()})",
            ConstructorInfo ctor => $", ObfuscatedRuntime.IlMetadataResolver.ResolveConstructor(\"{ctor.DeclaringType?.AssemblyQualifiedName}\", new[] {{ {string.Join(", ", ctor.GetParameters().Select(param => $"\"{param.ParameterType.AssemblyQualifiedName}\""))} }})",
            FieldInfo field => $", ObfuscatedRuntime.IlMetadataResolver.ResolveField(\"{field.DeclaringType?.AssemblyQualifiedName}\", \"{field.Name}\", {field.IsStatic.ToString().ToLowerInvariant()})",
            _ => throw new NotSupportedException($"Unsupported operand type: {operand.GetType().Name}")
        };
    }

    private static string EscapeString(string value)
    {
        return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    private static void AppendRuntime(StringBuilder sb)
    {
        sb.AppendLine("namespace ObfuscatedRuntime");
        sb.AppendLine("{");
        sb.AppendLine("    internal readonly record struct IlInstruction(int Offset, OpCode OpCode, object? Operand);");
        sb.AppendLine("    internal readonly record struct IlMethodDefinition(string CacheKey, IlInstruction[] Instructions, Type[] Locals, bool InitLocals);");
        sb.AppendLine();
        sb.AppendLine("    internal static class IlRuntime");
        sb.AppendLine("    {");
        sb.AppendLine("        private static readonly ConcurrentDictionary<string, DynamicMethod> Cache = new();");
        sb.AppendLine();
        sb.AppendLine("        public static object? Execute(IlMethodDefinition definition, Type returnType, Type[] parameterTypes, object?[] args)");
        sb.AppendLine("        {");
        sb.AppendLine("            var method = Cache.GetOrAdd(definition.CacheKey, _ => BuildDynamicMethod(definition, returnType, parameterTypes));");
        sb.AppendLine("            return method.Invoke(null, args);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public static void ExecuteVoid(IlMethodDefinition definition, Type returnType, Type[] parameterTypes, object?[] args)");
        sb.AppendLine("        {");
        sb.AppendLine("            var method = Cache.GetOrAdd(definition.CacheKey, _ => BuildDynamicMethod(definition, returnType, parameterTypes));");
        sb.AppendLine("            method.Invoke(null, args);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        private static DynamicMethod BuildDynamicMethod(IlMethodDefinition definition, Type returnType, Type[] parameterTypes)");
        sb.AppendLine("        {");
        sb.AppendLine("            var dynamicMethod = new DynamicMethod(definition.CacheKey, returnType, parameterTypes, typeof(IlRuntime).Module, true)");
        sb.AppendLine("            {");
        sb.AppendLine("                InitLocals = definition.InitLocals");
        sb.AppendLine("            };");
        sb.AppendLine("            var il = dynamicMethod.GetILGenerator();");
        sb.AppendLine("            foreach (var local in definition.Locals)");
        sb.AppendLine("            {");
        sb.AppendLine("                il.DeclareLocal(local);");
        sb.AppendLine("            }");
        sb.AppendLine("            Emit(il, definition.Instructions);");
        sb.AppendLine("            return dynamicMethod;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        private static void Emit(ILGenerator il, IlInstruction[] instructions)");
        sb.AppendLine("        {");
        sb.AppendLine("            var labels = new Dictionary<int, Label>();");
        sb.AppendLine("            foreach (var instruction in instructions)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (instruction.Operand is int target)");
        sb.AppendLine("                {");
        sb.AppendLine("                    if (!labels.ContainsKey(target))");
        sb.AppendLine("                    {");
        sb.AppendLine("                        labels[target] = il.DefineLabel();");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                else if (instruction.Operand is int[] targets)");
        sb.AppendLine("                {");
        sb.AppendLine("                    foreach (var targetOffset in targets)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        if (!labels.ContainsKey(targetOffset))");
        sb.AppendLine("                        {");
        sb.AppendLine("                            labels[targetOffset] = il.DefineLabel();");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            foreach (var instruction in instructions)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (labels.TryGetValue(instruction.Offset, out var label))");
        sb.AppendLine("                {");
        sb.AppendLine("                    il.MarkLabel(label);");
        sb.AppendLine("                }");
        sb.AppendLine("                EmitInstruction(il, instruction, labels);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        private static void EmitInstruction(ILGenerator il, IlInstruction instruction, Dictionary<int, Label> labels)");
        sb.AppendLine("        {");
        sb.AppendLine("            var opCode = instruction.OpCode;");
        sb.AppendLine("            var operand = instruction.Operand;");
        sb.AppendLine("            switch (opCode.OperandType)");
        sb.AppendLine("            {");
        sb.AppendLine("                case OperandType.InlineNone:");
        sb.AppendLine("                    il.Emit(opCode);");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.ShortInlineI:");
        sb.AppendLine("                    il.Emit(opCode, Convert.ToSByte(operand));");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineI:");
        sb.AppendLine("                    il.Emit(opCode, Convert.ToInt32(operand));");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineI8:");
        sb.AppendLine("                    il.Emit(opCode, Convert.ToInt64(operand));");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.ShortInlineR:");
        sb.AppendLine("                    il.Emit(opCode, Convert.ToSingle(operand));");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineR:");
        sb.AppendLine("                    il.Emit(opCode, Convert.ToDouble(operand));");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineString:");
        sb.AppendLine("                    il.Emit(opCode, (string)operand!);");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.ShortInlineVar:");
        sb.AppendLine("                    il.Emit(opCode, Convert.ToByte(operand));");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineVar:");
        sb.AppendLine("                    il.Emit(opCode, Convert.ToInt16(operand));");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineBrTarget:");
        sb.AppendLine("                case OperandType.ShortInlineBrTarget:");
        sb.AppendLine("                    il.Emit(opCode, labels[Convert.ToInt32(operand)]);");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineSwitch:");
        sb.AppendLine("                    var targets = ((int[])operand!).Select(target => labels[target]).ToArray();");
        sb.AppendLine("                    il.Emit(opCode, targets);");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineMethod:");
        sb.AppendLine("                    if (operand is ConstructorInfo ctor)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        il.Emit(opCode, ctor);");
        sb.AppendLine("                    }");
        sb.AppendLine("                    else");
        sb.AppendLine("                    {");
        sb.AppendLine("                        il.Emit(opCode, (MethodInfo)operand!);");
        sb.AppendLine("                    }");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineField:");
        sb.AppendLine("                    il.Emit(opCode, (FieldInfo)operand!);");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineType:");
        sb.AppendLine("                    il.Emit(opCode, (Type)operand!);");
        sb.AppendLine("                    break;");
        sb.AppendLine("                case OperandType.InlineTok:");
        sb.AppendLine("                    switch (operand)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        case FieldInfo field:");
        sb.AppendLine("                            il.Emit(opCode, field);");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        case MethodInfo method:");
        sb.AppendLine("                            il.Emit(opCode, method);");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        case ConstructorInfo constructor:");
        sb.AppendLine("                            il.Emit(opCode, constructor);");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        case Type type:");
        sb.AppendLine("                            il.Emit(opCode, type);");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        default:");
        sb.AppendLine("                            throw new NotSupportedException($\"Unsupported token operand: {operand?.GetType().Name}\");");
        sb.AppendLine("                    }");
        sb.AppendLine("                    break;");
        sb.AppendLine("                default:");
        sb.AppendLine("                    throw new NotSupportedException($\"Unsupported operand type: {opCode.OperandType}\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal static class IlMetadataResolver");
        sb.AppendLine("    {");
        sb.AppendLine("        public static Type ResolveType(string typeName)");
        sb.AppendLine("        {");
        sb.AppendLine("            return Type.GetType(typeName, throwOnError: true)!;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public static MethodInfo ResolveMethod(string declaringTypeName, string name, string[] parameterTypeNames, bool isStatic)");
        sb.AppendLine("        {");
        sb.AppendLine("            var declaringType = ResolveType(declaringTypeName);");
        sb.AppendLine("            var parameterTypes = parameterTypeNames.Select(ResolveType).ToArray();");
        sb.AppendLine("            var flags = BindingFlags.Public | BindingFlags.NonPublic | (isStatic ? BindingFlags.Static : BindingFlags.Instance);");
        sb.AppendLine("            return declaringType.GetMethod(name, flags, binder: null, types: parameterTypes, modifiers: null)!;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public static ConstructorInfo ResolveConstructor(string declaringTypeName, string[] parameterTypeNames)");
        sb.AppendLine("        {");
        sb.AppendLine("            var declaringType = ResolveType(declaringTypeName);");
        sb.AppendLine("            var parameterTypes = parameterTypeNames.Select(ResolveType).ToArray();");
        sb.AppendLine("            var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;");
        sb.AppendLine("            return declaringType.GetConstructor(flags, binder: null, types: parameterTypes, modifiers: null)!;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public static FieldInfo ResolveField(string declaringTypeName, string name, bool isStatic)");
        sb.AppendLine("        {");
        sb.AppendLine("            var declaringType = ResolveType(declaringTypeName);");
        sb.AppendLine("            var flags = BindingFlags.Public | BindingFlags.NonPublic | (isStatic ? BindingFlags.Static : BindingFlags.Instance);");
        sb.AppendLine("            return declaringType.GetField(name, flags)!;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public static MemberInfo ResolveMember(string declaringTypeName, string name)");
        sb.AppendLine("        {");
        sb.AppendLine("            var declaringType = ResolveType(declaringTypeName);");
        sb.AppendLine("            return declaringType.GetMember(name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static).First();");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }
}
